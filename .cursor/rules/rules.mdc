---
description: 
globs: 
alwaysApply: true
---
The physics simulation engine is the heart of the system, responsible for accurately modeling the black hole environment in real time. It will be implemented in C++ for performance (with possible use of templates or intrinsics for vector math, and carefully chosen algorithms for numerical integration). Key responsibilities and components of the physics engine include:
Relativistic Ray Tracing Module: Computes the path of light (photons) in the black hole’s spacetime to produce gravitational lensing visuals. In a full general relativistic approach, we solve the geodesic equations for light. For a non-rotating (Schwarzschild) black hole, these equations can be simplified using energy and angular momentum constants, but we may still perform numerical integration for generality (especially if we support a rotating Kerr black hole). This module might be utilized in two ways: (1) via GPU shaders (as described in the frontend) for per-pixel calculations – in that case the engine provides the shader formulas and any needed lookup tables or precomputed data; (2) on the CPU for certain tasks like precomputing an “Einstein ring” shape or verifying accuracy. The engine will include routines to integrate a photon's trajectory given initial conditions (position and direction). We can use a fixed-step integrator (like leapfrog or Runge-Kutta) for stability​
OSEISKAR.GITHUB.IO
, and stop conditions such as detecting when the photon hits the event horizon or escapes to infinity. The results of ray tracing (if done on CPU) would be an array of intersection results (e.g. what object or background pixel the ray hits), which would then inform rendering. However, since real-time performance is crucial, primary ray tracing for the main view is expected to be handled on GPU. The CPU module serves for auxiliary calculations, lower-fidelity previews, or computing physics for non-visualization purposes (e.g. computing the size of the black hole shadow analytically to overlay a marker).
Orbital Mechanics & Particle Dynamics: This component simulates massive particles around the black hole – e.g., stars, gas parcels in the accretion disk, or test particles dropped near the hole. We will support two regimes:
Newtonian / Keplerian orbits: For simplicity and speed, we might simulate particles using Newton’s gravity (with adjustments for strong field if needed). For example, a small star orbiting far from the black hole could be updated with a simple gravitational force law. This is not accurate very close to the event horizon, but can serve as an approximation for some elements.
General Relativistic orbits: For particles very near the black hole or for accuracy, we use relativistic equations (geodesics for massive particles). The engine can implement the Schwarzschild geodesic equations for massive bodies, which are similar to the photon case but include the particle’s rest mass and allow bound orbits. We may leverage known formulae for circular orbits (e.g. the innermost stable circular orbit radius) to place accretion disk matter. The engine can update each particle’s position and velocity each time step by solving the geodesic ODEs. Because this is computationally expensive, we will limit the number of simulated particles to a manageable amount (or use a clever approach like treating the disk as a continuous fluid with a simple velocity field).
We will incorporate time dilation in these simulations: for example, if an object or particle is moving relativistically or deep in the gravity well, its internal clock (for animation or a blinking light etc.) will be slowed. The engine can compute a time dilation factor for each entity based on the gravitational potential and velocity (e.g. using the Schwarzschild metric’s time component for static observers, or velocity time dilation from special relativity). This factor can be sent to the rendering layer to adjust animations. For instance, if we show a flashing beacon on a spaceship orbiting near the event horizon, the engine might tell the renderer to slow its flash rate according to gravitational time dilation.
Accretion Disk Model: Simulating a full fluid dynamics of an accretion disk in real time is beyond scope (that requires solving MHD equations). Instead, the engine will use a simplified model:
Represent the disk as either (a) a set of particles on circular orbits, or (b) a textured disk mesh with shader effects. In either case, the engine provides the necessary parameters for rendering. If using particles, the engine initializes them on circular orbits around the black hole (from just outside the innermost stable orbit out to some radius) and updates their positions each frame. Their orbital speeds include relativistic corrections (e.g. using $v=\sqrt{GM/(r c^2)}$ for circular orbit in Schwarzschild) and can include precession if we want to be fancy. If using a disk mesh, the engine might not need to update much per frame except perhaps an overall rotation angle, since a rigid disk could be pre-textured with relativistic effects.
The engine will calculate Doppler shift and beaming for the disk’s emission: matter orbiting toward the observer appears brighter/bluer, and matter receding appears dimmer/redder. In Seiskari’s demo, for example, they arbitrarily shifted the Milky Way background colors to simulate Doppler shift​
OSEISKAR.GITHUB.IO
. We can do a more physically based approach: compute Doppler factor $D = \gamma^{-1}(1 - \beta \cos\theta)$ for the emitter’s velocity relative to the line of sight​
OSEISKAR.GITHUB.IO
, and use it to modulate the light. The engine can supply the velocity field of the disk and the angle to observer so that the shader can tint the disk accordingly.
Gravitational redshift: Light climbing out of the gravitational well is redshifted. The engine can compute the redshift factor for light originating from the disk’s radius. This can be combined with Doppler for overall color shift. We might simplify and bake these effects into the shader rather than explicitly computing every frame, but the physics engine ensures the necessary values (e.g. gravitational potential at disk’s location) are available for the renderer.
Hawking Radiation Effect: While physically negligible for a large black hole, we will create a visual effect to illustrate Hawking radiation for educational value. The engine can periodically spawn virtual particle pairs just outside the event horizon – one labeled “escaping” (Hawking radiation) and one “falling in”. This can be done at a low rate (to not overwhelm the scene; just a few particles per second). These particles might be purely visual (handled by the renderer’s particle system), but the engine can control the rate based on black hole mass (Hawking radiation power is inversely related to mass – smaller black holes radiate more). For example, if the user reduces the black hole mass drastically (making it tiny), the engine could ramp up the particle emission rate to illustrate the concept that tiny black holes evaporate quickly. The motion of these particles can be a simple outward trajectory away from the black hole at near-light speed. The engine doesn’t need to compute actual quantum effects – just orchestrate the timing and perhaps the energy (color) of these particles for the renderer.
Numerical Methods and Optimization: The physics engine will use efficient numerical methods to update simulations:
We will likely use a fixed or adaptive timestep integrator for motion (Runge-Kutta 4 or a symplectic integrator for orbits to preserve stability). The timestep might be linked to the frame rate or decoupled (running at a higher rate if needed for accuracy and interpolating for rendering).
For performance, vectorized math libraries like GLM (OpenGL Mathematics) can be used for 4x4 matrices, vectors, and perhaps even to represent quaternions for orientations. Many computations in GR involve 4-vectors; GLM or a custom struct with SIMD could help speed this up.
If the number of objects becomes large (e.g. many particles in the disk), we could offload some calculations to multiple threads or even the GPU. For example, computing N-body gravity (if we ever simulate multiple bodies mutually interacting, though currently only BH’s gravity is dominant) could use OpenMP to distribute across cores.
Memory management will be done carefully to avoid GC pauses (in C++ there’s no GC, but we avoid fragmentation or allocate upfront). The engine will expose thread-safe interfaces if needed so the rendering thread can query data without stalling while physics is mid-update (double buffering state is one approach).
The engine should also allow turning off certain calculations if not needed – e.g., if the user turns off “particle trajectory” visualization, we can stop updating those to save CPU.
API of Physics Engine: The engine exposes a C API (or C++ API) that the server layer or frontends call. Key functions might include:
initSimulation(parameters) – initialize or reset the simulation with a given black hole mass, spin, initial objects, etc.
updateParameter(param, value) – set parameters at runtime (mass, spin, toggle effects).
stepSimulation(dt) – advance the physics by dt (in, say, seconds of simulated time).
getFrameData() – returns a struct or JSON with current state needed for rendering. This might contain camera recommended time dilation, an array of particle positions (for disk or any test particles), maybe an array of photons or ray data (though for rendering we don’t pass every photon – that’s done in shader). It could also include derived info like the size of the black hole shadow, gravitational redshift factors, etc., that the front-end might display as numbers or use in rendering.
shutdownSimulation() – cleanup.
Additionally, if using a Python server, we might create Python bindings for these (using pybind11 or CFFI) so that the Python code can call stepSimulation etc., directly.